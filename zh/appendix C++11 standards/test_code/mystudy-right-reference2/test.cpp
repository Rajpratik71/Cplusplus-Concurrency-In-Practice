/*
 * 1.c++中临时对象可能会大量存在，比如string/STL调用中。
 * 临时对象中的资源（buffer或者字符串）会随着临时对象的析构而消失，
 * 所以一般会在对象析构前把它们（资源）拷贝出来，而不会直接引用这些资源，否则会野指针。
 * 其实，既然已经是临时对象了，马上就会被析构掉，所以赶在析构前改一下里面的内容也不会带来太多负面影响，
 * 当然是在控制良好的前提下。基于这个思路，我们可以放心大胆的直接引用临时对象中的资源指针（比如指针赋值，引用该资源），
 * 然后把它置空（防止被临时对象释放掉，囧），或者更屌一点的，把我们意图释放的指针，直接赋值给临时对象的该指针，
 * 借助临时对象在析构时会释放它的资源的时机，把我们想释放的东西给释放掉！
 * 多么精妙！
 * 2.在c11之前，临时对象只能以 const MyClass& my_object 这种方式传递，有const在，所以临时对象是不能被修改的。
 * 但是c11引入了右值引用 MyClass&&，导致我们可以修改临时变量了！
 * 假如你是函数的提供者，你提供了带右值引用的参数，那么，你就大胆的去引用它的资源，修改它的资源吧，不用担心它还会被使用到，当函数返回之后。
 * 因为它是右值引用，该函数的调用者会保证这个参数不会再被使用到。
 * 3.假如你是函数的调用者，当你发现你有一个左值对象my_object即将不再被使用到了，就可以用move语义把它转成右值引用丢给函数，
 * 任函数去修改它的内容无所谓，因为你确定它不再被使用了（如果你确定不了，那就不能使用move语义）。
 * 当然，假如你处理的已经是右值了（比如函数返回值），那就跟以前没什么两样。
 * --------------------- 
 * 作者：摸不着头脑蛤 
 * 来源：CSDN 
 * 原文：https://blog.csdn.net/zjjzhaohang/article/details/67633910 
 * 版权声明：本文为博主原创文章，转载请附上博文链接！
**/
#include <iostream>
#include <vector>
#include <string>
 
using namespace std;
 
int main()
{
    string A("abc");
    string&& Rval = std::move(A);
    string B(Rval);    // this is a copy , not move.
    cout << A << endl;   // output "abc"
    string C(std::forward<string>(Rval));  // move.
    cout << A << endl;       /* output "" */
    return 0;
}
